#' Add object Metadata
#'
#' Adds data to the object to produce a object with metadata added.
#'
#' @param object A object
#' @param datapath Path to file containing metadata
#'
#' @return a single cell object
#' @export
setGeneric("format_new_metadata", function(object, datapath) {
    standardGeneric("format_new_metadata")
})

setMethod(
    "format_new_metadata", "Seurat",
    function(object, datapath) {
        new_meta <- read_csv(datapath) %>%
            mutate(across(contains("snn"), as.factor))

        rowname_col <- colnames(new_meta)[1]

        new_meta <- column_to_rownames(new_meta, rowname_col)

        object <- Seurat::AddMetaData(object, new_meta)
        DefaultAssay(object) <- "gene"
        ncalc <- Seurat:::CalcN(object)
        object$nFeature_RNA <- ncalc$nFeature
        object$nCount_RNA <- ncalc$nCount

        return(object)
    }
)

setMethod(
    "format_new_metadata", "SingleCellExperiment",
    function(object, datapath) {
        new_meta <- read_csv(datapath) %>%
            mutate(across(contains("snn"), as.factor))

        rowname_col <- colnames(new_meta)[1]

        new_meta <- column_to_rownames(new_meta, rowname_col)

        colData(object) <- new_meta

        # DefaultAssay(object) <- "gene"
        object <- addPerCellQC(object)
        object$nFeature_gene <- object$detected
        object$nCount_gene <- ncalc$sum

        return(object)
    }
)

#' Reformat object Metadata
#'
#' Reformat object Metadata by Coalesced Columns
#'
#' @param object A object
#' @param cols Columns
#' @param new_col New columns
#'
#' @return updated cell level metadata
#' @export
setGeneric("combine_cols", function(object, cols, new_col) {
    standardGeneric("combine_cols")
})

setMethod(
    "combine_cols", "Seurat",
    function(object, cols, new_col) {
        new_col <- janitor::make_clean_names(new_col)
        drop_cols <- cols[!cols == new_col]
        na_cols <- purrr::map_lgl(cols, ~ all(is.na(object[[.x]])))
        cols <- cols[!na_cols]
        meta <- rownames_to_column(get_cell_metadata(object)) %>%
            dplyr::mutate_at(vars(one_of(cols)), as.character) %>%
            mutate(`:=`(!!new_col, dplyr::coalesce(!!!syms(cols)))) %>%
            select(-drop_cols) %>%
            column_to_rownames(var = "rowname") %>%
            identity()
    }
)

setMethod(
    "combine_cols", "SingleCellExperiment",
    function(object, cols, new_col) {
        new_col <- janitor::make_clean_names(new_col)
        drop_cols <- cols[!cols == new_col]
        na_cols <- purrr::map_lgl(cols, ~ all(is.na(object[[.x]])))
        cols <- cols[!na_cols]
        meta <- rownames_to_column(get_cell_metadata(object)) %>%
            dplyr::mutate_at(vars(one_of(cols)), as.character) %>%
            mutate(`:=`(!!new_col, dplyr::coalesce(!!!syms(cols)))) %>%
            select(-drop_cols) %>%
            column_to_rownames(var = "rowname") %>%
            identity()
    }
)

#' Get Transcripts in object
#'
#' Get transcript ids in objects for one or more gene of interest
#'
#' @param object A object
#' @param gene Gene of intrest
#' @param organism Organism
#'
#' @return transcripts constituting a gene of interest in a single cell object
#' @export
#'
#' @examples
#'
#' RXRG_transcripts <- get_transcripts_from_object(human_gene_transcript_object, "RXRG")
#'
setGeneric("get_transcripts_from_object", function(object, gene, organism = "human") {
    standardGeneric("get_transcripts_from_object")
})

setMethod(
    "get_transcripts_from_object", "Seurat",
    function(object, gene, organism = "human") {
        transcripts <- genes_to_transcripts(gene, organism)

        transcripts <- transcripts[transcripts %in% rownames(retrieve_assay(object, "transcript"))]
    }
)

setMethod(
    "get_transcripts_from_object", "SingleCellExperiment",
    function(object, gene, organism = "human") {
        transcripts <- genes_to_transcripts(gene, organism)

        transcripts <- transcripts[transcripts %in% rownames(retrieve_assay(object, "transcript"))]
    }
)


#' Record Experiment Metadata
#'
#' Records miscellaneous data
#' @param object A object
#' @param experiment_name name of the experiment
#' @param organism human or mouse
#'
#' @return a single cell object
#' @export
setGeneric("record_experiment_data", function(object, experiment_name = "default_experiment", organism = "human") {
    standardGeneric("record_experiment_data")
})

setMethod(
    "record_experiment_data", "Seurat",
    function(object, experiment_name = "default_experiment", organism = "human") {
        if (!requireNamespace("Seurat", quietly = TRUE)) {
            stop("Package 'object' needed for this function to work. Please install it.",
                call. = FALSE
            )
        }

        organism <- Misc(object, "experiment")[["organism"]] %||% organism

        experiment_name <- Misc(object, "experiment")[["experiment_name"]] %||% experiment_name

        message(paste0("[", format(Sys.time(), "%H:%M:%S"), "] Logging Technical Details..."))
        experiment <- list(
            experiment_name = experiment_name,
            organism = organism
        )
        experiment$date_of_export <- Sys.Date()
        experiment$date_of_analysis <- Sys.Date()

        experiment$parameters <- list(
            gene_nomenclature = "gene_symbol",
            discard_genes_expressed_in_fewer_cells_than = 10,
            keep_mitochondrial_genes = TRUE,
            variables_to_regress_out = "nCount_RNA",
            number_PCs = 30,
            tSNE_perplexity = 30,
            cluster_resolution = seq(0.2, 2.0, by = 0.2)
        )
        experiment$filtering <- list(
            UMI_min = 50,
            genes_min = 10
        )
        experiment$sessionInfo <- list(
            capture.output(sessionInfo())
        )

        if (!is.null(object@version)) {
            experiment$seurat_version <- object@version
        }

        experiment$chevreul_version <- utils::packageVersion("chevreul")


        Misc(object, slot = "experiment") <- experiment

        return(object)
    }
)

setMethod(
    "record_experiment_data", "SingleCellExperiment",
    function(object, experiment_name = "default_experiment", organism = "human") {
        if (!requireNamespace("Seurat", quietly = TRUE)) {
            stop("Package 'object' needed for this function to work. Please install it.",
                call. = FALSE
            )
        }

        organism <- metadata(human_gene_transcript_sce)[["experiment"]][["organism"]] %||% organism

        experiment_name <- metadata(object)[["experiment"]][["experiment_name"]] %||% experiment_name

        message(paste0("[", format(Sys.time(), "%H:%M:%S"), "] Logging Technical Details..."))
        experiment <- list(
            experiment_name = experiment_name,
            organism = organism
        )
        experiment$date_of_export <- Sys.Date()
        experiment$date_of_analysis <- Sys.Date()

        experiment$parameters <- list(
            gene_nomenclature = "gene_symbol",
            discard_genes_expressed_in_fewer_cells_than = 10,
            keep_mitochondrial_genes = TRUE,
            variables_to_regress_out = "nCount_RNA",
            number_PCs = 30,
            tSNE_perplexity = 30,
            cluster_resolution = seq(0.2, 2.0, by = 0.2)
        )
        experiment$filtering <- list(
            UMI_min = 50,
            genes_min = 10
        )
        experiment$sessionInfo <- list(
            capture.output(sessionInfo())
        )

        if (!is.null(objectVersion(object))) {
            experiment$SingleCellExperiment_version <- objectVersion(object)
        }

        experiment$chevreul_version <- utils::packageVersion("chevreul")


        metadata(object)[["experiment"]] <- experiment

        return(object)
    }
)

#' Update a chevreul Object
#'
#' @param object_path Path to a object
#' @param feature gene or transcript of interest
#' @param resolution resolution for louvain clustering
#' #' @param return_object whether to return the single cell object
#' @param ... extra args passed to object_cluster
#'
#' @return a single cell object
#' @export
setGeneric("update_chevreul_object", function(object_path, feature, resolution = seq(0.2, 2.0, by = 0.2), return_object = TRUE, ...) {
    standardGeneric("update_chevreul_object")
})

setMethod(
    "update_chevreul_object", "Seurat",
    function(object_path, feature, resolution = seq(0.2, 2.0, by = 0.2), return_object = TRUE, ...) {
        message(object_path)
        object <- readRDS(object_path)

        if (is.list(object)) {
            object <- convert_object_list_to_multimodal(object)
            # object <- Seurat::UpdateSeuratObject(object)
        } else if (all(names(object@assays) == "RNA")) {
            object <- RenameAssays(object, RNA = "gene")
        } else if (identical(names(object@assays), c("RNA", "integrated"))) {
            object <- RenameAssays(object, RNA = "gene")
        }

        seurat_version <- Misc(object)$experiment$seurat_version

        if (packageVersion("Seurat") == "5.0.0" & (seurat_version < 5 || is.null(seurat_version))) {
            object <- convert_v3_to_v5(object)
        }

        object <- propagate_spreadsheet_changes(get_cell_metadata(object), object)

        # set appropriate assay
        if ("integrated" %in% names(object@assays)) {
            default_assay <- "integrated"
        } else {
            default_assay <- "gene"
        }

        DefaultAssay(object) <- default_assay

        cluster_tag <- glue::glue("{DefaultAssay(object)}_snn_res\\.")

        cluster_names <- str_subset(names(get_cell_metadata(object)), cluster_tag)
        new_cluster_names <- str_replace(cluster_names, cluster_tag, "cluster_resolution_")

        new_cluster_cols <- get_cell_metadata(object)[cluster_names]
        names(new_cluster_cols) <- new_cluster_names

        new_meta <- cbind(get_cell_metadata(object), new_cluster_cols)

        object <- set_metadata(object, new_meta)

        chevreul_version <- Misc(object)$experiment$chevreul_version

        chevreul_version <- ifelse(is.null(chevreul_version), 0.1, chevreul_version)

        # update human gene symbols to grch38
        old_symbol <- "CTC-378H22.2"
        if (old_symbol %in% rownames(object[["gene"]])) {
            for (i in names(object@assays)[names(object@assays) %in% c("gene", "integrated")]) {
                # object <- update_human_gene_symbols(object, assay = i)
            }
        }

        if (chevreul_version < getNamespaceVersion("chevreul")) {
            message(paste0(object_path, " is out of date! updating..."))
            if (!any(grepl("_snn_res", colnames(get_cell_metadata(object))))) {
                object <- object_cluster(object = object, resolution = resolution, reduction = "pca", ...)
            }

            for (i in names(object@assays)[names(object@assays) %in% c("gene", "integrated")]) {
                object <- find_all_markers(object, object_assay = i)
            }

            object <- record_experiment_data(object, ...)
            object <- object_calcn(object)
        }


        if (return_object) {
            return(object)
        } else {
            message(paste0("saving ", object_path))
            # saveRDS(object, gsub(".rds", "_multimodal.rds", object_path))
            saveRDS(object, object_path)
        }
    }
)

setMethod(
    "update_chevreul_object", "SingleCellExperiment",
    function(object_path, feature, resolution = seq(0.2, 2.0, by = 0.2), return_object = TRUE, ...) {
        message(object_path)
        object <- readRDS(object_path)

        if (is.list(object)) {
            object <- convert_object_list_to_multimodal(object)
            # object <- Seurat::UpdateSeuratObject(object)
        } else if (all(names(object@assays) == "RNA")) {
            object <- RenameAssays(object, RNA = "gene")
        } else if (identical(names(object@assays), c("RNA", "integrated"))) {
            object <- RenameAssays(object, RNA = "gene")
        }

        seurat_version <- Misc(object)$experiment$seurat_version

        if (packageVersion("Seurat") == "5.0.0" & (seurat_version < 5 || is.null(seurat_version))) {
            object <- convert_v3_to_v5(object)
        }

        object <- propagate_spreadsheet_changes(get_cell_metadata(object), object)

        # set appropriate assay
        if ("integrated" %in% names(object@assays)) {
            default_assay <- "integrated"
        } else {
            default_assay <- "gene"
        }

        DefaultAssay(object) <- default_assay

        cluster_tag <- glue::glue("{DefaultAssay(object)}_snn_res\\.")

        cluster_names <- str_subset(names(get_cell_metadata(object)), cluster_tag)
        new_cluster_names <- str_replace(cluster_names, cluster_tag, "cluster_resolution_")

        new_cluster_cols <- get_cell_metadata(object)[cluster_names]
        names(new_cluster_cols) <- new_cluster_names

        new_meta <- cbind(get_cell_metadata(object), new_cluster_cols)

        object <- set_metadata(object, new_meta)

        chevreul_version <- Misc(object)$experiment$chevreul_version

        chevreul_version <- ifelse(is.null(chevreul_version), 0.1, chevreul_version)

        # update human gene symbols to grch38
        old_symbol <- "CTC-378H22.2"
        if (old_symbol %in% rownames(object[["gene"]])) {
            for (i in names(object@assays)[names(object@assays) %in% c("gene", "integrated")]) {
                # object <- update_human_gene_symbols(object, assay = i)
            }
        }

        if (chevreul_version < getNamespaceVersion("chevreul")) {
            message(paste0(object_path, " is out of date! updating..."))
            if (!any(grepl("_snn_res", colnames(get_cell_metadata(object))))) {
                object <- object_cluster(object = object, resolution = resolution, reduction = "pca", ...)
            }

            for (i in names(object@assays)[names(object@assays) %in% c("gene", "integrated")]) {
                object <- find_all_markers(object, object_assay = i)
            }

            object <- record_experiment_data(object, ...)
            object <- object_calcn(object)
        }


        if (return_object) {
            return(object)
        } else {
            message(paste0("saving ", object_path))
            # saveRDS(object, gsub(".rds", "_multimodal.rds", object_path))
            saveRDS(object, object_path)
        }
    }
)

#' Calculate Read Count Metrics for a object
#'
#' Recalculate counts/features per cell for a object
#'
#' @param object A single cell object
#' @param assay Assay to use, Default = "gene"
#' @param slot slot for data
#'
#' @return a single cell object with nfeatures and ngenes stored in metadata
#' @export
setGeneric("object_calcn", function(object, assay = "gene", slot = "counts") standardGeneric("object_calcn"))

setMethod(
    "object_calcn", "Seurat",
    function(object, assay = "gene", slot = "counts") {
        n.calc <- Seurat:::CalcN(object = GetAssay(object, assay))
        if (!is.null(x = n.calc)) {
            names(x = n.calc) <- paste(names(x = n.calc), assay, sep = "_")
            object[[names(x = n.calc)]] <- n.calc
        }
        return(object)
    }
)

setMethod(
    "object_calcn", "SingleCellExperiment",
    function(object, assay = "gene", slot = "counts") {
        n.calc <- Seurat:::CalcN(object = GetAssay(object, assay))
        if (!is.null(x = n.calc)) {
            names(x = n.calc) <- paste(names(x = n.calc), assay, sep = "_")
            object[[names(x = n.calc)]] <- n.calc
        }
        return(object)
    }
)


#' Propagate Metadata Changes
#'
#' @param updated_table updated metadata
#' @param object a single cell object
#'
#' @return a single cell object
#' @export
propagate_spreadsheet_changes <- function(updated_table, object) {
    meta <- updated_table

    sample_ids <- rownames(meta)

    meta <- meta %>%
        mutate(meta, across(contains("snn"), as.factor)) %>%
        mutate(across(where(is.ordered), ~ as.factor(as.character(.x))))

    rownames(meta) <- sample_ids

    object <- set_metadata(object, meta)

    return(object)
}

#' Create a database of chevreul projects
#'
#' Create a database containing chevreul projects
#'
#' @param cache_location Path to cache "~/.cache/chevreul"
#' @param sqlite_db Database to be created
#' @param verbose print messages
#'
#' @return a sqlite database with single cell objects
#' @export
setGeneric("create_project_db", function(cache_location = "~/.cache/chevreul", sqlite_db = "single-cell-projects.db", verbose = TRUE) standardGeneric("create_project_db"))

setMethod(
    "create_project_db", "Seurat",
    function(cache_location = "~/.cache/chevreul", sqlite_db = "single-cell-projects.db", verbose = TRUE) {
        if (!dir.exists(cache_location)) {
            dir.create(cache_location)
        }
        con <- dbConnect(RSQLite::SQLite(), path(cache_location, sqlite_db))
        projects_tbl <- tibble::tibble(project_name = character(), project_path = character(), project_slug = character(), project_type = character(), )
        message(paste0("building table of chevreul projects at ", path(cache_location, sqlite_db)))
        tryCatch({
            dbWriteTable(con, "projects_tbl", projects_tbl)
        }, warning = function(w) {
            message(sprintf("Warning in %s: %s", deparse(w[["call"]]), w[["message"]]))
        }, error = function(e) {
            message("projects db already exists!")
        }, finally = {
        })
        dbDisconnect(con)
    }
)

setMethod(
    "create_project_db", "SingleCellExperiment",
    function(cache_location = "~/.cache/chevreul", sqlite_db = "single-cell-projects.db", verbose = TRUE) {
        if (!dir.exists(cache_location)) {
            dir.create(cache_location)
        }
        con <- dbConnect(RSQLite::SQLite(), path(cache_location, sqlite_db))
        projects_tbl <- tibble::tibble(project_name = character(), project_path = character(), project_slug = character(), project_type = character(), )
        message(paste0("building table of chevreul projects at ", path(cache_location, sqlite_db)))
        tryCatch({
            dbWriteTable(con, "projects_tbl", projects_tbl)
        }, warning = function(w) {
            message(sprintf("Warning in %s: %s", deparse(w[["call"]]), w[["message"]]))
        }, error = function(e) {
            message("projects db already exists!")
        }, finally = {
        })
        dbDisconnect(con)
    }
)
#' Update a database of chevreul projects
#'
#' Add new/update existing projects to the database by recursing fully
#'
#' @param projects_dir The project directory to be updated
#' @param cache_location Path to cache "~/.cache/chevreul"
#' @param sqlite_db sqlite db
#' @param verbose print messages
#'
#' @return a sqlite database with single cell objects
#' @export
update_project_db <- function(projects_dir = NULL,
    cache_location = "~/.cache/chevreul",
    sqlite_db = "single-cell-projects.db",
    verbose = TRUE) {
    if (!dir.exists(cache_location)) {
        dir.create(cache_location)
    }

    con <- dbConnect(RSQLite::SQLite(), path(cache_location, sqlite_db))

    projects_tbl <-
        dir_ls(projects_dir, glob = "*.here", recurse = TRUE, fail = FALSE, all = TRUE) %>%
        path_dir(.) %>%
        purrr::set_names(path_file(.)) %>%
        enframe("project_name", "project_path") %>%
        mutate(project_slug = str_remove(project_name, "_proj$")) %>%
        mutate(project_type = path_file(path_dir(project_path))) %>%
        identity()

    current_projects_tbl <-
        DBI::dbReadTable(con, "projects_tbl") %>%
        filter(fs::file_exists(project_path)) %>%
        filter(!project_path %in% projects_tbl$project_path) %>%
        bind_rows(projects_tbl) %>%
        distinct(project_path, .keep_all = TRUE)

    dbWriteTable(con, "projects_tbl", projects_tbl, overwrite = TRUE)

    dbDisconnect(con)
}

#' Update a database of chevreul projects
#'
#' Append projects to datatbase
#'
#' @param new_project_path new project path
#' @param projects_dir project directory
#' @param cache_location Path to cache "~/.cache/chevreul"
#' @param sqlite_db sqlite db
#' @param verbose print messages
#'
#'
#' @return a sqlite database with single cell objects
#' @export
append_to_project_db <- function(new_project_path, projects_dir = NULL,
    cache_location = "~/.cache/chevreul",
    sqlite_db = "single-cell-projects.db",
    verbose = TRUE) {
    if (!dir.exists(cache_location)) {
        dir.create(cache_location)
    }

    con <- dbConnect(RSQLite::SQLite(), path(cache_location, sqlite_db))

    projects_tbl <-
        new_project_path %>%
        purrr::set_names(path_file(.)) %>%
        enframe("project_name", "project_path") %>%
        mutate(project_slug = str_remove(project_name, "_proj$")) %>%
        mutate(project_type = path_file(path_dir(project_path))) %>%
        identity()

    current_projects_tbl <-
        DBI::dbReadTable(con, "projects_tbl") %>%
        filter(fs::file_exists(project_path)) %>%
        filter(!project_path %in% projects_tbl$project_path) %>%
        bind_rows(projects_tbl) %>%
        distinct(project_path, .keep_all = TRUE)

    dbWriteTable(con, "projects_tbl", current_projects_tbl, overwrite = TRUE)

    dbDisconnect(con)
}

#' Read a database of chevreul projects
#'
#' Reads database of chevreul projects to a data frame
#'
#' @param projects_dir project directory
#' @param cache_location Path to cache "~/.cache/chevreul"
#' @param sqlite_db sqlite db
#' @param verbose print messages
#'
#' @return a tibble with single cell objects
#' @export
read_project_db <- function(projects_dir = NULL,
    cache_location = "~/.cache/chevreul",
    sqlite_db = "single-cell-projects.db",
    verbose = TRUE) {
    if (!dir.exists(cache_location)) {
        dir.create(cache_location)
    }

    con <- dbConnect(RSQLite::SQLite(), path(cache_location, sqlite_db))

    current_projects_tbl <-
        DBI::dbReadTable(con, "projects_tbl")

    dbDisconnect(con)

    return(current_projects_tbl)
}

#' Make Bigwig Database
#'
#'
#' @param new_project Project directory
#' @param cache_location Path to cache "~/.cache/chevreul"
#' @param sqlite_db sqlite db containing bw files
#'
#' @return a sqlite database of bigwig files for cells in a single cell object
#' @export
make_bigwig_db <- function(new_project = NULL, cache_location = "~/.cache/chevreul/", sqlite_db = "bw-files.db") {
    new_bigwigfiles <- dir_ls(new_project, glob = "*.bw", recurse = TRUE) %>%
        purrr::set_names(path_file(.)) %>%
        enframe("name", "bigWig") %>%
        mutate(sample_id = str_remove(name, "_Aligned.sortedByCoord.out.*bw$")) %>%
        filter(!stringr::str_detect(name, "integrated")) %>%
        distinct(sample_id, .keep_all = TRUE) %>%
        identity()

    con <- dbConnect(RSQLite::SQLite(), dbname = path(cache_location, sqlite_db))

    all_bigwigfiles <-
        dbReadTable(con, "bigwigfiles") %>%
        bind_rows(new_bigwigfiles)

    dbWriteTable(con, "bigwigfiles", all_bigwigfiles, overwrite = TRUE)

    return(all_bigwigfiles)
}

#' Retrieve Metadata from Batch
#'
#' @param batch batch
#' @param projects_dir path to project dir
#' @param db_path path to .db file
#'
#' @return a tibble with cell level metadata from a single cell object
metadata_from_batch <- function(batch, projects_dir = "/dataVolume/storage/single_cell_projects",
    db_path = "single-cell-projects.db") {
    mydb <- dbConnect(RSQLite::SQLite(), path(projects_dir, db_path))

    projects_tbl <- dbReadTable(mydb, "projects_tbl") %>%
        filter(!project_type %in% c("integrated_projects", "resources"))

    dbDisconnect(mydb)

    metadata <-
        projects_tbl %>%
        filter(project_slug == batch) %>%
        pull(project_path) %>%
        path("data") %>%
        dir_ls(glob = "*.csv") %>%
        identity()
}

#' convert object list to multimodal object
#'
#' @param object_list a list of objects
#'
#' @return a list of single cell objects
#' @export
convert_object_list_to_multimodal <- function(object_list) {
    colnames(object_list[["gene"]]@meta.data) <- gsub("RNA_", "gene_", colnames(object_list[["gene"]]@meta.data))

    multimodal_object <- object_list$gene
    multimodal_object <- RenameAssays(multimodal_object, RNA = "gene")

    if ("transcript" %in% names(object_list)) {
        if (identical(length(Cells(object_list$gene)), length(Cells(object_list$transcript)))) {
            colnames(object_list[["transcript"]]@meta.data) <- gsub("RNA_", "transcript_", colnames(object_list[["transcript"]]@meta.data))
            multimodal_object[["transcript"]] <- object_list$transcript$RNA
            transcript_markers <- grepl("transcript_", names(object_list$transcript@meta.data))
            transcript_cluster_cols <- object_list[["transcript"]]@meta.data[transcript_markers]
            if (length(transcript_cluster_cols) > 0) {
                multimodal_object <- AddMetaData(multimodal_object, transcript_cluster_cols)
            }
        }
    }

    marker_names <- names(Misc(multimodal_object)[["markers"]])

    if (!is.null(Misc(multimodal_object)$markers)) {
        names(Misc(multimodal_object)$markers) <- gsub("RNA", "gene", marker_names)
    }


    return(multimodal_object)
}

#' Clean Vector of Chevreul Names
#'
#' Cleans names of objects provided in a vector form
#'
#' @param myvec A vector of object names
#'
#' @return a clean vector of object names
#' @export
make_chevreul_clean_names <- function(myvec) {
    myvec %>%
        purrr::set_names(stringr::str_to_title(stringr::str_replace_all(., "[^[:alnum:][:space:]\\.]", " ")))
}


#' Convert seurat to seurat V5 format
#'
#' Convert seurat from v3 to v5 format
#'
#' @param seurat_v3 a version 3 seurat
#'
#' @return a verstion 5 seurat
#' @export
#'
#' @examples
#' convert_v3_to_v5(human_gene_transcript_seurat)
convert_v3_to_v5 <- function(seurat_v3) {
    seurat_version <- Misc(seurat_v3)$experiment$seurat_version

    if (seurat_version < 5 || is.null(seurat_version)) {
        meta <- seurat_v3@meta.data

        seurat_v5 <- CreateSeuratObject(counts = seurat_v3$gene@counts, data = seurat_v3$gene@data, assay = "gene", meta.data = meta)

        transcript_assay.v5 <- CreateAssay5Object(counts = seurat_v3$transcript@counts, data = seurat_v3$transcript@data)
        seurat_v5$transcript <- transcript_assay.v5

        seurat_v5$gene <- seurat_preprocess(seurat_v5$gene, normalize = FALSE)
        seurat_v5$transcript <- seurat_preprocess(seurat_v5$transcript, normalize = FALSE)

        # seurat_v5 <- clustering_workflow(seurat_v5)
        seurat_v5@reductions <- seurat_v3@reductions
        seurat_v5@graphs <- seurat_v3@graphs
        seurat_v5@neighbors <- seurat_v3@neighbors

        Misc(seurat_v5) <- Misc(seurat_v3)

        Idents(seurat_v5) <- Idents(seurat_v3)

        Misc(seurat_v5)$experiment$seurat_version <- packageVersion("seurat")
    } else {
        seurat_v5 <- seurat_v3
    }

    return(seurat_v5)
}

#' Get genes from Object
#'
#' Get genes from the object
#'
#' @param object a single cell object
#'
#' @return a vector of genes in a single cell object
#' @export
setGeneric("genes_from_object", function(object, ...) {
    standardGeneric("genes_from_object")
})

setMethod("genes_from_object", "Seurat", function(object) {
    #rownames(object@assays[[assay]])
     rownames(object)
})

setMethod("genes_from_object", "SingleCellExperiment", function(object) {
    rownames(object)
})

#' Get metadata from object
#'
#' Get metadata from the given object
#'
#' @param object a single cell object
#'
#' @return a tibble with metadata from a single cell object
#' @export
setGeneric("metadata_from_object", function(object) {
    standardGeneric("metadata_from_object")
})

setMethod("metadata_from_object", "Seurat", function(object) {
    colnames(object[[]])
})

setMethod("metadata_from_object", "SingleCellExperiment", function(object) {
    colnames(colData(object))
})

convert_seurat_to_sce <- function(seu) {
    sce <- as.SingleCellExperiment(seu, assay = DefaultAssay(seu))

    alt_exp_names <- Seurat::Assays(seu)[!Seurat::Assays(seu) == DefaultAssay(seu)]

    for (i in alt_exp_names) {
        altExp(sce, i) <- as.SingleCellExperiment(seu, assay = i)
    }

    sce@metadata <- seu@misc

    return(sce)
}
